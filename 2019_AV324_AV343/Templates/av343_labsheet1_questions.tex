\begin{enumerate}
\item Suppose $x_{1}$ and $x_{2}$ are two finite sequences defined as
  \begin{eqnarray*}
    x_{1}[n] & = & [4,2,6,3,8,1,5] \\
    x_{2}[n] & = & [3,8,6,9,6,7]
  \end{eqnarray*}
  Let the starting index of $x_{1}[n]$ be $-1$ (i.e. $x_{1}[-1] = 4, x_{1}[0] = 2 \dots$) and the starting index of $x_{2}[n]$ be -2.
  Obtain the convolution of $x_{1}[n]$ and $x_{2}[n]$ using Matlab
  \begin{enumerate}
  \item You should first try an implementation on your own without using any inbuilt functions.
  \item Now find out whether there are any inbuilt Matlab functions that can be used to compute convolution and use that.
  \end{enumerate}
\item Find out what is meant by auto-correlation of a discrete time signal $x[n]$. Find out the auto-correlation of $x_{1}[n]$ and $x_{2}[n]$ defined above using your own code. Find out whether there is a builtin Matlab function for finding out the auto-correlation. Find out the auto-correlation of $x_{1}[n]$ and $x_{2}[n]$ using the builtin function(s). Find out whether auto-correlation can be implemented using convolution.
\item Find out what is meant by cross-correlation between two discrete time signals $x_{1}[n]$ and $x_{2}[n]$. Find out whether cross-correlation is implemented as a builtin function in Matlab. Find the cross-correlation between $x_{1}[n]$ and $x_{2}[n]$ using your own code as well as builtin functions. Find out whether cross-correlation can be implemented using convolution.
\item Define what odd and even signals are. Write Matlab code to find out the odd and even parts of the following signals:
  \begin{enumerate}
  \item $x_{1}[n] = [4, 3, 5, 6, 7, 2]$; starting index is $-2$
  \item $x_{2}[n] = sin(2\pi 100n) + cos(\pi 100 n)$ for all $n$ (but choose an appropriate finite time extent for implementation)
  \end{enumerate}


\item Let $h[n]$ as defined below be the impulse response of a discrete time LTI system
  \begin{eqnarray*}
    h[n] & = &
    \begin{cases}
      n, \text{ for } n \in \brac{0,1,2,\dots,10}, \\
      0, \text{ otherwise.}
    \end{cases}
  \end{eqnarray*}
  Using Matlab, plot the frequency response of this system (plot the magnitude and phase spectra separately).
  Note that the frequency response is the DTFT which is a continuous function of the frequency $\omega$.
  Therefore, a sufficiently ``smooth'' discretization of $\omega$ is needed for obtaining these plots.
  Observe whether the frequency responses are periodic with $\omega$ or not.
\item Write a Matlab function to plot the frequency response (magnitude and phase) corresponding to any $h[n]$, rather than the specific case above. The function should take $h[n]$ and two variables ``dbscale'', ``actualfreq'' as input. The function should produce the magnitude and phase response as output. If the ``dbscale'' variable is 1 then the magnitude should be plotted in decibels. If the ``actualfreq'' variable is not $-1$, then the $\omega$ axis should be plotted in actual frequencies by interpreting the value of the ``actualfreq'' variable as the sampling frequency used to produce the discrete time signal (i.e., the time duration between two samples is $1/actualfreq$). Test this function with example inputs (you are free to choose non-trivial inputs) and demonstrate that your implementation is correct. The inputs should be chosen carefully to test the function.
\item We know that if a discrete time LTI system has an impulse response $h[n]$ and if the input to the system is $x[n]$, then the output (defined as $y[n]$) is given by the discrete time convolution of $x[n]$ and $h[n]$.
  \begin{enumerate}
  \item Write a Matlab function ``discreteTimeConvolve'' that takes as inputs the impulse response and the input signal and produces the output signal as output. Please note that this function should not use any inbuilt Matlab functions to do convolution but rather implement convolution using basic array operations. 
  \item Now find out whether any inbuilt Matlab function can be used to directly implement convolution. Demonstrate the use of this function using 3 examples.
  \end{enumerate}
\item A discrete time LTI system can also be specified by a constant coefficient difference equation as follows:
  \begin{eqnarray*}
    y[n] = \sum_{k = 0}^{N} a_{k} x[n - k] + \sum_{l = 1}^{M} b_{l} y[n - l].
  \end{eqnarray*}
  \begin{enumerate}
  \item Implement a Matlab function ``discreteTimeCCDE'' that takes as input the set of $N+1$ coefficients $(a_{k})$ and $M$ coefficients $(b_{l})$ and an input signal $x[n]$ and produces as output the signal $y[n]$. Please note that any initial conditions can be taken as input or assumed. Do not use any inbuilt Matlab functions for this part.
  \item Now find out whether any inbuilt Matlab function can be used to directly implement the above operation. Demonstrate the use of this function using 3 examples. (Hint: we have seen this in class when we studied IIR filters.)
  \end{enumerate}
\item In this task, you will explore one of the most important properties of the DTFT. Suppose $h[n]$ is the impulse response of a discrete time LTI system. The LTI system has output $y[n]$ when $x[n]$ is the input. Let $H(\omega), X(\omega)$ and $Y(\omega)$ be the DTFTs of $h[n], x[n]$, and $y[n]$. We know that $Y(\omega) = H(\omega) X(\omega)$.
  \begin{enumerate}
  \item Write a Matlab function to compute the DTFT of a signal; note that you have already done this in (2) in this labsheet. The DTFT that is being computed is a suitably discretized version of the actual DTFT (defined for the continuous $\omega$).
  \item Using the above function compute $H(\omega)$ and $X(\omega)$ and their product $Y(\omega)$.
  \item Compute $y[n]$ by taking the inverse DTFT (think about how you will implement this on your computer; are there inbuilt Matlab functions that can help you implement this.)
  \item Compare the $y[n]$ that you have obtained with what is obtained via directly convolving $x[n]$ and $h[n]$. Are there any differences? If there are, then why do such differences arise.
  \end{enumerate}
  
  \item Review the following from the textbook
  \begin{enumerate}
  \item discrete Fourier transform (DFT) of a discrete time signal $x[n]$
  \item the inverse DFT 
  \end{enumerate}
\item Using the internet
  \begin{enumerate}
  \item https://en.wikipedia.org/wiki/Fast\_Fourier\_transform, 
  \item http://www.dspguide.com/ch12/2.htm,
  \end{enumerate}
  or using the textbook by Oppenheim and Schafer (Chapter 9 and also Chapter 8), get an idea about what fast Fourier transform (FFT) is. Then using Matlab's documentation (or internet resources) study what the following inbuilt Matlab functions do. Pay attention to the inputs and outputs of these functions
  \begin{enumerate}
  \item dftmtx
  \item fft
  \item ifft
  \item fftshift
  \end{enumerate}

\item Implementation of DFT and IDFT.
  \begin{enumerate}
  \item Write a Matlab function named ``mydft1'' that computes the N-point DFT of a discrete time signal $x[n]$ where $n \in \brac{0,1,\dots, N - 1}$.
    \begin{enumerate}
    \item The input $x[n]$ is assumed to extend from $0$ to $N - 1$ and can be a Matlab vector, and 
    \item the function should implement DFT using loops, and 
    \item the function should return the N-point DFT as another Matlab vector.
    \end{enumerate}
  \item Write a Matlab function named ``myidft1'' that computes the N-point IDFT of a DFT $X[k]$ where $k \in \brac{0,1,\dots, N - 1}$.
    \begin{enumerate}
    \item The input $X[k]$ is assumed to extend from $0$ to $N - 1$ and can be a Matlab vector, and 
    \item the function should implement IDFT using loops, and 
    \item the function should return the N-point signal $x[n]$ as another Matlab vector.
    \end{enumerate}
  \item 
    \begin{enumerate}
    \item Using mydft1() compute the 16-point DFT of $x[n] = cos(2\pi (0.25)n)$ for $n \in \brac{0, \dots, 15}$.
    \item Test whether myidft1(mydft1($x[n]$)) = $x[n]$.
    \end{enumerate}
  \item Write a Matlab function named ``mydft2'' that computes the N-point DFT of a discrete time signal $x[n]$ where $n \in \brac{0,1,\dots, N - 1}$.
    \begin{enumerate}
    \item The input $x[n]$ is assumed to extend from $0$ to $N - 1$ and can be a Matlab vector, and 
    \item the function should implement DFT using dftmx,
    \item the function should return the N-point DFT as another Matlab vector.
    \end{enumerate}
  \item Write a Matlab function named ``myidft2'' that computes the N-point IDFT of a DFT $X[k]$ where $k \in \brac{0,1,\dots, N - 1}$.
    \begin{enumerate}
    \item The input $X[k]$ is assumed to extend from $0$ to $N - 1$ and can be a Matlab vector, and 
    \item the function should implement IDFT using dftmx, and 
    \item the function should return the N-point signal $x[n]$ as another Matlab vector.
    \end{enumerate}
      \item 
    \begin{enumerate}
    \item Using mydft2() compute the 16-point DFT of $x[n] = cos(2\pi (0.25)n)$ for $n \in \brac{0, \dots, 15}$.
    \item Test whether myidft2(mydft2($x[n]$)) = $x[n]$.
    \end{enumerate}
  \end{enumerate}
\item Let $x[n] = cos(2\pi (0.25)n)$ for $n \in \brac{0, \dots, 15}$.
  \begin{enumerate}
  \item Compute the 16-point DFT of $x[n]$ using the fft function
  \item Assuming that $x[n]$ was obtained by sampling at a rate of $1$ Hz, plot the DFT (magnitude and phase separately) with the frequency axis in the range $[0, 2\pi]$ radians/sec.
  \item Assuming that $x[n]$ was obtained by sampling at a rate of $1$ Hz, plot the DFT (magnitude and phase separately) with the frequency axis in the range $[-\pi, \pi]$ radians/sec. Use the fftshift function for this task.
  \item Check if ifft(fft($x[n]$) is $x[n]$.
  \end{enumerate}
\item Suppose $x_{1}$ and $x_{2}$ are two finite sequences defined as
  \begin{eqnarray*}
    x_{1}[n] & = & [4,2,6,3,8,1] \\
    x_{2}[n] & = & [3,8,6,9,6,7]
  \end{eqnarray*}
  Write a Matlab program to compute the circular convolution of $x_{1}[n]$ and $x_{2}[n]$.
  Modify your Matlab program such that it can compute the circular convolution of any $x_{1}$ and $x_{2}$ given as input - include in your program logic to check whether the circular convolution can be computed and return appropriate error messages.

\item Suppose we have two signals defined as follows:
  \begin{eqnarray*}
    x[n] & = &
    \begin{cases}
      (0,1,2,3,4) \text{ for } n \in \brac{0,1,2,3,4}, \text{ and}, \\
      0 \text{ otherwise }
    \end{cases}\\
    h[n] & = &
    \begin{cases}
      (1,1,1,1,1) \text{ for } n \in \brac{0,1,2,3,4}, \text{ and}, \\
      0 \text{ otherwise }
    \end{cases}
  \end{eqnarray*}
  \begin{enumerate}
  \item Calculate the circular convolution of $x[n]$ and $h[n]$ manually.
  \item Using Matlab array operations or vector operations compute the circular convolution of $x[n]$ and $h[n]$
  \item Using Matlab documentation study what the inbuilt function circshift does. Compute the circular convolution of $x[n]$ and $h[n]$ using circshift. Compare with the result obtained in (a) and (b)
  \item Using Matlab documentation study what the inbuilt function cconv does. Compute the circular convolution of $x[n]$ and $h[n]$ using cconv. Compare with the results obtained in (a), (b), and (c)
  \item Using fft and ifft compute the circular convolution of $x[n]$ and $h[n]$ and compare with the results obtained in (a), (b), (c), and (d)
  \end{enumerate}
\item Suppose we have two signals defined as follows:
  \begin{eqnarray*}
    x[n] & = &
    \begin{cases}
      (0,1,2,3,4) \text{ for } n \in \brac{0,1,2,3,4}, \text{ and}, \\
      0 \text{ otherwise }
    \end{cases}\\
    h[n] & = &
    \begin{cases}
      (4,5,3) \text{ for } n \in \brac{0,1,2}, \text{ and}, \\
      0 \text{ otherwise }
    \end{cases}
  \end{eqnarray*}
  \begin{enumerate}
  \item Calculate the linear convolution of $x[n]$ and $h[n]$ manually.
  \item Using fft and ifft compute the linear convolution of $x[n]$ and $h[n]$ and compare with the result obtained in (a)
  \end{enumerate}
\item Suppose we have a periodic signal $x[n]$ with period $5$ defined as follows:
  \begin{eqnarray*}
    x[n] & = & (0,1,2,3,4) \text{ for } n \in \brac{0,1,2,3,4}.
  \end{eqnarray*}
  So $x[n]$ is $(\dots, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, \dots)$.
  Also let $h[n]$ be defined as
  \begin{eqnarray*}
    h[n] & = &
    \begin{cases}
      (3,2,1) \text{ for } n \in \brac{0,1,2}, \text{ and}, \\
      0 \text{ otherwise }
    \end{cases}
  \end{eqnarray*}
  Let $y[n]$ be $x[n]$ considered for $5$ periods from $n = 0$, i.e., $y[n] = x[n]$ for $n \in \brac{0, \dots, 24}$.
  Also let $y[n] = 0$ for all other $n$.
  \begin{enumerate}
  \item Compute the linear convolution of $y[n]$ with $h[n]$ in time domain.
  \item Compute the linear convolution of $y[n]$ with $h[n]$ using fft and ifft. Compare your result with that obtained above.
  \item Review the overlap and add method taught in class from your class notes. Compute the linear convolution of $y[n]$ with $h[n]$ using overlap and add method. Choose at least 3 disjoint segments for the $y[n]$ signal (i.e., express $y[n] = y_{1}[n] + y_{2}[n] + y_{3}[n]$, such that each signal $y_{i}[n]$ has an extent which is disjoint with the extents of the other signals $y_{j}[n]$) . Check whether the linear convolution that you obtain matches with the results above.
  \end{enumerate}

\end{enumerate}


